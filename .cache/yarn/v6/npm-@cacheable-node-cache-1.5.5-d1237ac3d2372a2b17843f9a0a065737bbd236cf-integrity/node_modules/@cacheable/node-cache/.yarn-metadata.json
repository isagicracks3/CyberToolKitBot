{
  "manifest": {
    "name": "@cacheable/node-cache",
    "version": "1.5.5",
    "description": "Simple and Maintained fast NodeJS internal caching",
    "type": "module",
    "main": "./dist/index.cjs",
    "module": "./dist/index.js",
    "types": "./dist/index.d.ts",
    "exports": {
      ".": {
        "require": "./dist/index.cjs",
        "import": "./dist/index.js"
      }
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/jaredwray/cacheable.git",
      "directory": "packages/node-cache"
    },
    "author": {
      "name": "Jared Wray",
      "email": "me@jaredwray.com"
    },
    "license": "MIT",
    "private": false,
    "keywords": [
      "cache",
      "caching",
      "node",
      "nodejs",
      "cacheable",
      "cacheable-node-cache",
      "node-cache",
      "cacheable-node"
    ],
    "devDependencies": {
      "@types/node": "^22.15.7",
      "@vitest/coverage-v8": "^3.1.3",
      "rimraf": "^6.0.1",
      "tsup": "^8.4.0",
      "typescript": "^5.8.3",
      "vitest": "^3.1.3",
      "xo": "^0.60.0"
    },
    "dependencies": {
      "hookified": "^1.8.2",
      "keyv": "^5.3.3",
      "cacheable": "^1.9.0"
    },
    "files": [
      "dist",
      "license"
    ],
    "scripts": {
      "build": "rimraf ./dist && tsup src/index.ts --format cjs,esm --dts --clean",
      "prepublish": "pnpm build",
      "test": "xo --fix && vitest run --coverage",
      "test:ci": "xo && vitest run",
      "clean": "rimraf ./dist ./coverage ./node_modules"
    },
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-@cacheable-node-cache-1.5.5-d1237ac3d2372a2b17843f9a0a065737bbd236cf-integrity/node_modules/@cacheable/node-cache/package.json",
    "readmeFilename": "README.md",
    "readme": "[<img align=\"center\" src=\"https://cacheable.org/symbol.svg\" alt=\"Cacheable\" />](https://github.com/jaredwray/cacheable)\n\n# Node-Cache\n\n> Simple and Maintained fast Node.js caching\n\n[![codecov](https://codecov.io/gh/jaredwray/cacheable/graph/badge.svg?token=lWZ9OBQ7GM)](https://codecov.io/gh/jaredwray/cacheable)\n[![tests](https://github.com/jaredwray/cacheable/actions/workflows/tests.yml/badge.svg)](https://github.com/jaredwray/cacheable/actions/workflows/tests.yml)\n[![npm](https://img.shields.io/npm/dm/@cacheable/node-cache.svg)](https://www.npmjs.com/package/@cacheable/node-cache)\n[![npm](https://img.shields.io/npm/v/@cacheable/node-cache)](https://www.npmjs.com/package/@cacheable/node-cache)\n[![license](https://img.shields.io/github/license/jaredwray/cacheable)](https://github.com/jaredwray/cacheable/blob/main/LICENSE)\n\n`@cacheable/node-cache` is compatible with the [node-cache](https://www.npmjs.com/package/node-cache) package with regular maintenance and additional functionality (async/await and storage adapters). The only thing not implemented is the `enableLegacyCallbacks` option and functions. If you need them we are happy to take a PR to add them.\n\n* Fully Compatible with `node-cache` using `{NodeCache}`\n* Async/Await functionality with `{NodeCacheStore}`\n* Storage Adapters via [Keyv](https://keyv.org) with `{NodeCacheStore}`\n* Maintained and Updated Regularly! ðŸŽ‰\n\nNote: `NodeCache` is ready and available for use. `NodeCacheStore` is in progress and will be available soon. Please do not use it until it is released.\n\n# Table of Contents\n* [Getting Started](#getting-started)\n* [Basic Usage](#basic-usage)\n* [Advanced Usage](#advanced-usage)\n* [NodeCacheStore](#nodecachestore)\n* [API](#api)\n* [How to Contribute](#how-to-contribute)\n* [License and Copyright](#license-and-copyright)\n\n# Getting Started\n\n```bash\nnpm install @cacheable/node-cache --save\n```\n\n# Basic Usage\n\n```javascript\nimport NodeCache from '@cacheable/node-cache';\n\nconst cache = new NodeCache();\ncache.set('foo', 'bar');\ncache.get('foo'); // 'bar'\n\ncache.set('foo', 'bar', 10); // 10 seconds\n\ncache.del('foo'); // true\n\ncache.set('bar', 'baz', '35m'); // 35 minutes using shorthand\n```\n\n# NodeCache Not Default Export\n\n```javascript\nimport {NodeCache} from '@cacheable/node-cache';\n\nconst cache = new NodeCache();\ncache.set('foo', 'bar');\ncache.get('foo'); // 'bar'\n```\n\n# Advanced Usage\n\n```javascript\nimport {NodeStorageCache} from '@cacheable/node-cache';\nimport {Keyv} from 'keyv';\nimport {KeyvRedis} from '@keyv/redis';\n\nconst storage = new Keyv({store: new KeyvRedis('redis://user:pass@localhost:6379')});\nconst cache = new NodeStorageCache(storage);\n\n// with storage you have the same functionality as the NodeCache but will be using async/await\nawait cache.set('foo', 'bar');\nawait cache.get('foo'); // 'bar'\n\n// if you call getStats() this will now only be for the single instance of the adapter as it is in memory\ncache.getStats(); // {hits: 1, misses: 1, keys: 1, ksize: 2, vsize: 3}\n```\n\n# NodeCacheStore\n\nThe `NodeCacheStore` is a class that extends the `NodeCache` and adds the ability to use storage adapters. This is based on the `cacheable` engine and allows you to do layer 1 and layer 2 caching. The storage adapters are based on the [Keyv](https://keyv.org) package. This allows you to use any of the storage adapters that are available.\n\n```javascript\nimport {NodeCacheStore} from '@cacheable/node-cache';\n\nconst cache = new NodeCacheStore();\ncache.set('foo', 'bar');\ncache.get('foo'); // 'bar'\n```\n\n## NodeCacheStoreOptions\n\nWhen initializing the cache you can pass in the options below:\n\n```javascript\nexport type NodeCacheStoreOptions = {\n\tttl?: number; // The standard ttl as number in milliseconds for every generated cache element. 0 = unlimited\n\tprimary?: Keyv; // The primary storage adapter\n\tsecondary?: Keyv; // The secondary storage adapter\n\tmaxKeys?: number; // Default is 0 (unlimited). If this is set it will throw and error if you try to set more keys than the max.\n\tstats?: boolean; // Default is true, if this is set to false it will not track stats\n};\n```\n\nNote: the `ttl` is now in milliseconds and not seconds like `stdTTL` in `NodeCache`. You can learn more about using shorthand also in the [cacheable documentation](https://github.com/jaredwray/cacheable/blob/main/packages/cacheable/README.md#shorthand-for-time-to-live-ttl). as it is fulling supported. Here is an example:\n\n```javascript\nconst cache = new NodeCacheStore({ttl: 60000 }); // 1 minute as it defaults to milliseconds\ncache.set('foo', 'bar', '1h'); // 1 hour\ncache.set('longfoo', 'bar', '1d'); // 1 day\n```\n\n## Node Cache Store API\n\n* `set(key: string | number, value: any, ttl?: number): Promise<boolean>` - Set a key value pair with an optional ttl (in milliseconds). Will return true on success. If the ttl is not set it will default to 0 (no ttl)\n* `mset(data: Array<NodeCacheItem>): Promise<boolean>` - Set multiple key value pairs at once\n* `get<T>(key: string | number): Promise<T>` - Get a value from the cache by key\n* `mget(keys: Array<string | number>): Promise<Record<string, unknown>>` - Get multiple values from the cache by keys\n* `take<T>(key: string | number): Promise<T>` - Get a value from the cache by key and delete it\n* `del(key: string | number): Promise<boolean>` - Delete a key\n* `mdel(keys: Array<string | number>): Promise<boolean>` - Delete multiple keys\n* `clear(): Promise<void>` - Clear the cache\n* `setTtl(key: string | number, ttl: number): Promise<boolean>` - Set the ttl of a key\n* `disconnect(): Promise<void>` - Disconnect the storage adapters\n* `stats`: `NodeCacheStats` - Get the stats of the cache\n* `ttl`: `number` | `string` - The standard ttl as number in seconds for every generated cache element. `< 0` or `undefined` = unlimited\n* `primary`: `Keyv` - The primary storage adapter\n* `secondary`: `Keyv` - The secondary storage adapter\n* `maxKeys`: `number` - If this is set it will throw and error if you try to set more keys than the max\n\n# API\n\n## `constructor(options?: NodeCacheOptions)`\n\nCreate a new cache instance. You can pass in options to set the configuration:\n\n```javascript\nexport type NodeCacheOptions = {\n\tstdTTL?: number; // The standard ttl as number in seconds for every generated cache element. 0 = unlimited. If string, it will be parsed as shorthand and default to milliseconds if it is a number as a string.\n\tcheckperiod?: number; // Default is 600, 0 means no periodic check\n\tuseClones?: boolean; // Default is true\n\tdeleteOnExpire?: boolean; // Default is true, if false it will keep the key and not delete during an interval check and the value on get() will be undefined\n\tmaxKeys?: number; // Default is -1 (unlimited). If this is set it will throw and error if you try to set more keys than the max.\n};\n```\n\nWhen initializing the cache you can pass in the options to set the configuration like the example below where we set the `stdTTL` to 10 seconds and `checkperiod` to 5 seconds.:\n\n```javascript\nconst cache = new NodeCache({stdTTL: 10, checkperiod: 5});\n```\n\nWhen setting `deleteOnExpire` to `true` it will delete the key when it expires. If you set it to `false` it will keep the key but the value on `get()` will be `undefined`. You can manage the key with `on('expired')` event.\n\n```javascript\nconst cache = new NodeCache({deleteOnExpire: false});\ncache.on('expired', (key, value) => {\n\tconsole.log(`Key ${key} has expired with value ${value}`);\n});\n```\n\n## `.set(key: string | number, value: any, ttl?: number): boolean`\n\nSet a key value pair with an optional ttl (in seconds). Will return true on success. If the ttl is not set it will default to 0 (no ttl).\n\n```javascript\ncache.set('foo', 'bar', 10); // true\n```\n\n## `.mset(data: Array<NodeCacheItem>): boolean`\n\nSet multiple key value pairs at once. This will take an array of objects with the key, value, and optional ttl.\n\n```javascript\ncache.mset([{key: 'foo', value: 'bar', ttl: 10}, {key: 'bar', value: 'baz'}]); // true\n```\n\nthe `NodeCacheItem` is defined as:\n\n```javascript\nexport type NodeCacheItem = {\n\tkey: string;\n\tvalue: any;\n\tttl?: number;\n};\n```\n\n## `.get(key: string | number): any`\n\nGet a value from the cache by key. If the key does not exist it will return `undefined`.\n\n```javascript\ncache.get('foo'); // 'bar'\n```\n\n## `mget(keys: Array<string | number>): Record<string, unknown>`\n\nGet multiple values from the cache by keys. This will return an object with the keys and values.\n\n```javascript\nconst obj = { my: 'value', my2: 'value2' };\nconst obj2 = { special: 'value3', life: 'value4' };\ncache.set('my', obj);\ncache.set('my2', obj2);\ncache.mget(['my', 'my2']); // { my: { my: 'value', my2: 'value2' }, my2: { special: 'value3', life: 'value4' } }\n```\n\n## `take(key: string | number): any`\n\nGet a value from the cache by key and delete it. If the key does not exist it will return `undefined`.\n\n```javascript\ncache.set('foo', 'bar');\ncache.take('foo'); // 'bar'\ncache.get('foo'); // undefined\n```\n\n## `del(key: string | number | Array<string | number>): number`\n\nDelete a key from the cache. Will return the number of deleted entries and never fail. You can also pass in an array of keys to delete multiple keys. All examples assume that you have initialized the cache like `const cache = new NodeCache();`.\n\n```javascript\ncache.del('foo'); // true\n```\n\npassing in an array of keys:\n\n```javascript\ncache.del(['foo', 'bar']); // true\n```\n\n## `.mdel(keys: Array<string | number>): number`\n\nDelete multiple keys from the cache. Will return the number of deleted entries and never fail.\n\n```javascript\ncache.mdel(['foo', 'bar']); // true\n```\n\n## `.ttl(key: string | number, ttl?: number): boolean`\n\nRedefine the ttl of a key. Returns true if the key has been found and changed. Otherwise returns false. If the ttl-argument isn't passed the default-TTL will be used.\n\n```javascript\ncache.ttl('foo', 10); // true\n```\n\n## `getTtl(key: string | number): number | undefined`\n\nGet the ttl expiration from `Date.now()` of a key. If the key does not exist it will return `undefined`.\n\n```javascript\ncache.getTtl('foo'); // 1725993344859\n```\n\n## `has(key: string | number): boolean`\n\nCheck if a key exists in the cache.\n\n```javascript\ncache.set('foo', 'bar');\ncache.has('foo'); // true\n```\n\n## `keys(): Array<string>`\n\nGet all keys from the cache.\n\n```javascript\ncache.keys(); // ['foo', 'bar']\n```\n\n## `getStats(): NodeCacheStats`\n\nGet the stats of the cache.\n\n```javascript\ncache.getStats(); // {hits: 1, misses: 1, keys: 1, ksize: 2, vsize: 3}\n```\n\n## `flushAll(): void`\n\nFlush the cache. Will remove all keys and reset the stats.\n\n```javascript\ncache.flushAll();\ncache.keys(); // []\ncache.getStats(); // {hits: 0, misses: 0, keys: 0, ksize: 0, vsize: 0}\n```\n\n## `flushStats(): void`\n\nFlush the stats. Will reset the stats but keep the keys.\n\n```javascript\ncache.set('foo', 'bar');\ncache.flushStats();\ncache.getStats(); // {hits: 0, misses: 0, keys: 0, ksize: 0, vsize: 0}\ncache.keys(); // ['foo']\n```\n\n## `close(): void`\n\nthis will stop the interval that is running for the `checkperiod` and `deleteOnExpire` options.\n\n```javascript\ncache.close();\n```\n\n## `on(event: string, callback: Function): void`\n\nListen to events. Here are the events that you can listen to:\n* `set` - when a key is set and it will pass in the `key` and `value`.\n* `expired` - when a key is expired and it will pass in the `key` and `value`.\n* `flush` - when the cache is flushed\n* `flush_stats` - when the stats are flushed\n* `del` - when a key is deleted and it will pass in the `key` and `value`.\n\n```javascript\ncache.on('set', (key, value) => {\n\tconsole.log(`Key ${key} has been set with value ${value}`);\n});\n```\n\n# How to Contribute\n\nYou can contribute by forking the repo and submitting a pull request. Please make sure to add tests and update the documentation. To learn more about how to contribute go to our main README [https://github.com/jaredwray/cacheable](https://github.com/jaredwray/cacheable). This will talk about how to `Open a Pull Request`, `Ask a Question`, or `Post an Issue`.\n\n# License and Copyright\n[MIT Â© Jared Wray](./LICENSE)",
    "licenseText": "MIT License & Â© Jared Wray \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@cacheable/node-cache/-/node-cache-1.5.5.tgz#d1237ac3d2372a2b17843f9a0a065737bbd236cf",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@cacheable/node-cache/-/node-cache-1.5.5.tgz",
    "hash": "d1237ac3d2372a2b17843f9a0a065737bbd236cf",
    "integrity": "sha512-pCvDtZbYIwWi2Rs3fgakM/EkzfLwNsdDMjvlb1cpPxUx0q5wiULsxTYHHhoXamFHAwVwgOM5gLaQzSAhYkDVoA==",
    "registry": "npm",
    "packageName": "@cacheable/node-cache",
    "cacheIntegrity": "sha512-pCvDtZbYIwWi2Rs3fgakM/EkzfLwNsdDMjvlb1cpPxUx0q5wiULsxTYHHhoXamFHAwVwgOM5gLaQzSAhYkDVoA== sha1-0SN6w9I3KisXhD+aCgZXN7vSNs8="
  },
  "registry": "npm",
  "hash": "d1237ac3d2372a2b17843f9a0a065737bbd236cf"
}