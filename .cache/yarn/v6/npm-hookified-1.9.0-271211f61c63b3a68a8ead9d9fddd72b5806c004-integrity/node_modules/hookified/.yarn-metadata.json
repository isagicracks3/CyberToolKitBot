{
  "manifest": {
    "name": "hookified",
    "version": "1.9.0",
    "description": "Event Emitting and Middleware Hooks",
    "type": "module",
    "main": "dist/node/index.cjs",
    "module": "dist/node/index.js",
    "exports": {
      ".": {
        "import": "./dist/node/index.js",
        "require": "./dist/node/index.cjs"
      },
      "./browser": {
        "import": "./dist/browser/index.js",
        "default": "./dist/browser/index.global.js"
      }
    },
    "types": "dist/node/index.d.ts",
    "scripts": {
      "test": "xo --fix && vitest run --coverage",
      "test:ci": "xo && vitest run --coverage",
      "clean": "rimraf ./dist ./coverage ./site/dist",
      "build": "rimraf ./dist && tsup",
      "benchmark": "pnpm benchmark:hooks && pnpm benchmark:emit",
      "benchmark:hooks": "pnpm tsx benchmark/hook.ts",
      "benchmark:emit": "pnpm tsx benchmark/emit.ts",
      "website:build": "docula build",
      "website:serve": "docula serve",
      "prepare": "pnpm build"
    },
    "keywords": [
      "hooks",
      "eventemitter",
      "eventemitter3",
      "middleware",
      "events",
      "hooks",
      "event-hooks",
      "hook-system",
      "event-driven",
      "event-emitter",
      "hook-handlers",
      "middleware",
      "emit",
      "event-management",
      "before-after-hooks",
      "event-listeners",
      "custom-hooks",
      "hook-utilities",
      "typescript-hooks"
    ],
    "repository": {
      "type": "git",
      "url": "git+https://github.com/jaredwray/hookified.git"
    },
    "author": {
      "name": "Jared Wray",
      "email": "me@jaredwray.com"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/jaredwray/hookified/issues"
    },
    "homepage": "https://github.com/jaredwray/hookified#readme",
    "devDependencies": {
      "@monstermann/tinybench-pretty-printer": "^0.1.0",
      "@vitest/coverage-v8": "^3.1.3",
      "docula": "^0.11.1",
      "emittery": "^1.1.0",
      "eventemitter3": "^5.0.1",
      "hookable": "^5.5.3",
      "pino": "^9.6.0",
      "rimraf": "^6.0.1",
      "tinybench": "^4.0.1",
      "tsup": "^8.4.0",
      "tsx": "^4.19.4",
      "typescript": "^5.8.3",
      "vitest": "^3.1.3",
      "xo": "^0.60.0"
    },
    "files": [
      "dist",
      "LICENSE"
    ],
    "pnpm": {
      "onlyBuiltDependencies": [
        "esbuild"
      ]
    },
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-hookified-1.9.0-271211f61c63b3a68a8ead9d9fddd72b5806c004-integrity/node_modules/hookified/package.json",
    "readmeFilename": "README.md",
    "readme": "![site/logo.svg](site/logo.svg)\n\n# Event Emitting and Middleware Hooks\n\n[![tests](https://github.com/jaredwray/hookified/actions/workflows/tests.yaml/badge.svg)](https://github.com/jaredwray/hookified/actions/workflows/tests.yaml)\n[![GitHub license](https://img.shields.io/github/license/jaredwray/hookified)](https://github.com/jaredwray/hookified/blob/master/LICENSE)\n[![codecov](https://codecov.io/gh/jaredwray/hookified/graph/badge.svg?token=nKkVklTFdA)](https://codecov.io/gh/jaredwray/hookified)\n[![npm](https://img.shields.io/npm/dm/hookified)](https://npmjs.com/package/hookified)\n[![jsDelivr](https://data.jsdelivr.com/v1/package/npm/hookified/badge)](https://www.jsdelivr.com/package/npm/hookified)\n[![npm](https://img.shields.io/npm/v/hookified)](https://npmjs.com/package/hookified)\n\n# Features\n- Simple replacement for EventEmitter\n- Async / Sync Middleware Hooks for Your Methods \n- ESM / CJS with Types and Nodejs 20+\n- Browser Support and Delivered via CDN\n- Ability to throw errors in hooks\n- Ability to pass in a logger (such as Pino) for errors\n- No package dependencies and only 100KB in size\n- Fast and Efficient with [Benchmarks](#benchmarks)\n- Maintained on a regular basis!\n\n# Table of Contents\n- [Installation](#installation)\n- [Usage](#usage)\n- [Using it in the Browser](#using-it-in-the-browser)\n- [API - Hooks](#api---hooks)\n  - [.throwHookErrors](#throwhookerrors)\n  - [.onHook(eventName, handler)](#onhookeventname-handler)\n  - [.onHooks(Array<HookEntry>)](#onhooksarrayhookentry)\n  - [.onceHook(eventName, handler)](#oncehookeventname-handler)\n  - [.prependHook(eventName, handler)](#prependhookeventname-handler)\n  - [.prependOnceHook(eventName, handler)](#prependoncehookeventname-handler)\n  - [.removeHook(eventName)](#removehookeventname)\n  - [.removeHooks(Array<HookEntry>)](#removehooksarrayhookentry)\n  - [.hook(eventName, ...args)](#hookeventname-args)\n  - [.hooks](#hooks)\n  - [.getHooks(eventName)](#gethookseventname)\n  - [.clearHooks(eventName)](#clearhookeventname)\n- [API - Events](#api---events)\n  - [.on(eventName, handler)](#oneventname-handler)\n  - [.off(eventName, handler)](#offeventname-handler)\n  - [.emit(eventName, ...args)](#emiteventname-args)\n  - [.listeners(eventName)](#listenerseventname)\n  - [.removeAllListeners(eventName)](#removealllistenerseventname)\n  - [.setMaxListeners(maxListeners: number)](#setmaxlistenersmaxlisteners-number)\n  - [.once(eventName, handler)](#oneventname-handler-1)\n  - [.prependListener(eventName, handler)](#prependlistenereventname-handler)\n  - [.prependOnceListener(eventName, handler)](#prependoncelistenereventname-handler)\n  - [.eventNames()](#eventnames)\n  - [.listenerCount(eventName?)](#listenercounteventname)\n  - [.rawListeners(eventName?)](#rawlistenerseventname)\n- [Development and Contribution](#development-and-contribution)\n- [Benchmarks](#benchmarks)\n- [License](#license)\n\n# Installation\n```bash\nnpm install hookified --save\n```\n\n# Usage\nThis was built because we constantly wanted hooks and events extended on libraires we are building such as [Keyv](https://keyv.org) and [Cacheable](https://cacheable.org). This is a simple way to add hooks and events to your classes.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World'); //using Emittery\n  }\n\n  //with hooks you can pass data in and if they are subscribed via onHook they can modify the data\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n```\n\nYou can even pass in multiple arguments to the hooks:\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    let data2 = { some: 'data2' };\n    // do something\n    await this.hook('before:myMethod2', data, data2);\n\n    return data;\n  }\n}\n```\n\n# Using it in the Browser\n\n```html\n<script type=\"module\">\n  import { Hookified } from 'https://cdn.jsdelivr.net/npm/hookified/dist/browser/index.js';\n\n  class MyClass extends Hookified {\n    constructor() {\n      super();\n    }\n\n    async myMethodEmittingEvent() {\n      this.emit('message', 'Hello World'); //using Emittery\n    }\n\n    //with hooks you can pass data in and if they are subscribed via onHook they can modify the data\n    async myMethodWithHooks() Promise<any> {\n      let data = { some: 'data' };\n      // do something\n      await this.hook('before:myMethod2', data);\n\n      return data;\n    }\n  }\n</script>\n```\n\nif you are not using ESM modules, you can use the following:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/hookified/dist/browser/index.global.js\"></script>\n<script>\n  class MyClass extends Hookified {\n    constructor() {\n      super();\n    }\n\n    async myMethodEmittingEvent() {\n      this.emit('message', 'Hello World'); //using Emittery\n    }\n\n    //with hooks you can pass data in and if they are subscribed via onHook they can modify the data\n    async myMethodWithHooks() Promise<any> {\n      let data = { some: 'data' };\n      // do something\n      await this.hook('before:myMethod2', data);\n\n      return data;\n    }\n  }\n</script>\n```\n\n# API - Hooks\n\n## .throwHookErrors\n\nIf set to true, errors thrown in hooks will be thrown. If set to false, errors will be only emitted.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super({ throwHookErrors: true });\n  }\n}\n\nconst myClass = new MyClass();\n\nconsole.log(myClass.throwHookErrors); // true. because it is set in super\n\ntry {\n  myClass.onHook('error-event', async () => {\n    throw new Error('error');\n  });\n\n  await myClass.hook('error-event');\n} catch (error) {\n  console.log(error.message); // error\n}\n\nmyClass.throwHookErrors = false;\nconsole.log(myClass.throwHookErrors); // false\n```\n\n## .logger\nIf set, errors thrown in hooks will be logged to the logger. If not set, errors will be only emitted.\n\n```javascript\nimport { Hookified } from 'hookified';\nimport pino from 'pino';\n\nconst logger = pino(); // create a logger instance that is compatible with Logger type\n\nclass MyClass extends Hookified {\n  constructor() {\n    super({ logger });\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async () => {\n  throw new Error('error');\n});\n\n// when you call before:myMethod2 it will log the error to the logger\nawait myClass.hook('before:myMethod2');\n```\n\n## .onHook(eventName, handler)\n\nSubscribe to a hook event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n```\n\n## .onHooks(Array<HookEntry>)\n\nSubscribe to multiple hook events at once\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    await this.hook('before:myMethodWithHooks', data);\n    \n    // do something here with the data\n    data.some = 'new data';\n\n    await this.hook('after:myMethodWithHooks', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nconst hooks = [\n  {\n    event: 'before:myMethodWithHooks',\n    handler: async (data) => {\n      data.some = 'new data1';\n    },\n  },\n  {\n    event: 'after:myMethodWithHooks',\n    handler: async (data) => {\n      data.some = 'new data2';\n    },\n  },\n];\n```\n\n## .onceHook(eventName, handler)\n\nSubscribe to a hook event once.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.onHookOnce('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n\nmyClass.myMethodWithHooks();\n\nconsole.log(myClass.hooks.length); // 0\n```\n\n## .prependHook(eventName, handler)\n\nSubscribe to a hook event before all other hooks.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\nmyClass.preHook('before:myMethod2', async (data) => {\n  data.some = 'will run before new data';\n});\n```\n\n## .prependOnceHook(eventName, handler)\n\nSubscribe to a hook event before all other hooks. After it is used once it will be removed.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\nmyClass.preHook('before:myMethod2', async (data) => {\n  data.some = 'will run before new data';\n});\n```\n\n## .removeHook(eventName)\n\nUnsubscribe from a hook event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nconst handler = async (data) => {\n  data.some = 'new data';\n};\n\nmyClass.onHook('before:myMethod2', handler);\n\nmyClass.removeHook('before:myMethod2', handler);\n```\n\n## .removeHooks(Array<HookEntry>)\nUnsubscribe from multiple hooks.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    await this.hook('before:myMethodWithHooks', data);\n    \n    // do something\n    data.some = 'new data';\n    await this.hook('after:myMethodWithHooks', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\n\nconst hooks = [\n  {\n    event: 'before:myMethodWithHooks',\n    handler: async (data) => {\n      data.some = 'new data1';\n    },\n  },\n  {\n    event: 'after:myMethodWithHooks',\n    handler: async (data) => {\n      data.some = 'new data2';\n    },\n  },\n];\nmyClass.onHooks(hooks);\n\n// remove all hooks\nmyClass.removeHook(hooks);\n```\n\n## .hook(eventName, ...args)\n\nRun a hook event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n```\n\nin this example we are passing multiple arguments to the hook:\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    let data2 = { some: 'data2' };\n    // do something\n    await this.hook('before:myMethod2', data, data2);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.onHook('before:myMethod2', async (data, data2) => {\n  data.some = 'new data';\n  data2.some = 'new data2';\n});\n\nawait myClass.myMethodWithHooks();\n```\n\n## .hooks\n\nGet all hooks.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n\nconsole.log(myClass.hooks);\n```\n\n## .getHooks(eventName)\n\nGet all hooks for an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n\nconsole.log(myClass.getHooks('before:myMethod2'));\n```\n\n## .clearHooks(eventName)\n\nClear all hooks for an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodWithHooks() Promise<any> {\n    let data = { some: 'data' };\n    // do something\n    await this.hook('before:myMethod2', data);\n\n    return data;\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.onHook('before:myMethod2', async (data) => {\n  data.some = 'new data';\n});\n\nmyClass.clearHooks('before:myMethod2');\n```\n\n# API - Events\n\n## .on(eventName, handler)\n\nSubscribe to an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n```\n\n## .off(eventName, handler)\n\nUnsubscribe from an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nmyClass.off('message', (message) => {\n  console.log(message);\n});\n```\n\n## .emit(eventName, ...args)\n\nEmit an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n```\n\n## .listeners(eventName)\n\nGet all listeners for an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nconsole.log(myClass.listeners('message'));\n```\n\n## .removeAllListeners(eventName)\n\nRemove all listeners for an event.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nmyClass.removeAllListeners('message');\n```\n\n## .setMaxListeners(maxListeners: number)\n\nSet the maximum number of listeners and will truncate if there are already too many.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n\n  async myMethodEmittingEvent() {\n    this.emit('message', 'Hello World');\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.setMaxListeners(1);\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nmyClass.on('message', (message) => {\n  console.log(message);\n}); // this will not be added and console warning\n\nconsole.log(myClass.listenerCount('message')); // 1\n```\n\n## .once(eventName, handler)\n\nSubscribe to an event once.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.once('message', (message) => {\n  console.log(message);\n});\n\nmyClass.emit('message', 'Hello World');\n\nmyClass.emit('message', 'Hello World'); // this will not be called\n```\n\n## .prependListener(eventName, handler)\n\nPrepend a listener to an event. This will be called before any other listeners.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.prependListener('message', (message) => {\n  console.log(message);\n});\n```\n\n## .prependOnceListener(eventName, handler)\n\nPrepend a listener to an event once. This will be called before any other listeners.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.prependOnceListener('message', (message) => {\n  console.log(message);\n});\n\nmyClass.emit('message', 'Hello World');\n```\n\n## .eventNames()\n\nGet all event names.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nconsole.log(myClass.eventNames());\n```\n\n## .listenerCount(eventName?)\n\nGet the count of listeners for an event or all events if evenName not provided.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nconsole.log(myClass.listenerCount('message')); // 1\n```\n\n## .rawListeners(eventName?)\n\nGet all listeners for an event or all events if evenName not provided.\n\n```javascript\nimport { Hookified } from 'hookified';\n\nclass MyClass extends Hookified {\n  constructor() {\n    super();\n  }\n}\n\nconst myClass = new MyClass();\n\nmyClass.on('message', (message) => {\n  console.log(message);\n});\n\nconsole.log(myClass.rawListeners('message'));\n```\n\n# Development and Contribution\n\nHookified is written in TypeScript and tests are written in `vitest`. To run the tests, use the following command:\n\nTo setup the environment and run the tests:\n\n```bash\npnpm i && pnpm test\n```\n\nNote that we are using `pnpm` as our package manager. If you don't have it installed, you can install it globally with:\n\n```bash\nnpm install -g pnpm\n```\n\nTo contribute follow the [Contributing Guidelines](CONTRIBUTING.md) and [Code of Conduct](CODE_OF_CONDUCT.md).\n\n# Benchmarks\n\nWe are doing very simple benchmarking to see how this compares to other libraries using `tinybench`. This is not a full benchmark but just a simple way to see how it performs. Our goal is to be as close or better than the other libraries including native (EventEmitter).\n\n## Hooks\n\n|       name        |  summary  |  ops/sec  |  time/op  |  margin  |  samples  |\n|-------------------|:---------:|----------:|----------:|:--------:|----------:|\n|  Hookified 1.8.0  |    🥇     |       4M  |    299ns  |  ±2.42%  |       3M  |\n|  Hookable 5.5.3   |   -73%    |     982K  |      1µs  |  ±2.92%  |     812K  |\n\n## Emits\n\nThis shows how close the native `EventEmitter` is to `hookified` and `eventemitter3`. We are using the same test as above but just emitting events. It is not a fair comparison but it is interesting to see how close they are.\n\n|          name           |  summary  |  ops/sec  |  time/op  |  margin  |  samples  |\n|-------------------------|:---------:|----------:|----------:|:--------:|----------:|\n|  Hookified 1.8.0        |    🥇     |      10M  |    112ns  |  ±1.13%  |       9M  |\n|  EventEmitter3 5.0.1    |   -1.3%   |      10M  |    114ns  |  ±1.84%  |       9M  |\n|  EventEmitter v22.12.0  |   -1.5%   |       9M  |    114ns  |  ±1.18%  |       9M  |\n|  Emittery 1.1.0         |   -92%    |     785K  |      1µs  |  ±0.45%  |     761K  |\n\n_Note: the `EventEmitter` version is Nodejs versioning._\n\n# License\n\n[MIT & © Jared Wray](LICENSE)\n\n\n\n\n",
    "licenseText": "MIT License & © Jared Wray\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/hookified/-/hookified-1.9.0.tgz#271211f61c63b3a68a8ead9d9fddd72b5806c004",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/hookified/-/hookified-1.9.0.tgz",
    "hash": "271211f61c63b3a68a8ead9d9fddd72b5806c004",
    "integrity": "sha512-2yEEGqphImtKIe1NXWEhu6yD3hlFR4Mxk4Mtp3XEyScpSt4pQ4ymmXA1zzxZpj99QkFK+nN0nzjeb2+RUi/6CQ==",
    "registry": "npm",
    "packageName": "hookified",
    "cacheIntegrity": "sha512-2yEEGqphImtKIe1NXWEhu6yD3hlFR4Mxk4Mtp3XEyScpSt4pQ4ymmXA1zzxZpj99QkFK+nN0nzjeb2+RUi/6CQ== sha1-JxIR9hxjs6aKjq2dn93XK1gGwAQ="
  },
  "registry": "npm",
  "hash": "271211f61c63b3a68a8ead9d9fddd72b5806c004"
}